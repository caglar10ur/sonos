// Code generated by makeservice based on the provided SCDP XML. DO NOT EDIT.

// Package audioin is a generated AudioIn package.
package audioin

import (
	"bytes"
	"encoding/xml"
	"errors"
	"io"
	"net/http"
	"net/url"
)

const (
	ServiceURN     = "urn:schemas-upnp-org:service:AudioIn:1"
	EncodingSchema = "http://schemas.xmlsoap.org/soap/encoding/"
	EnvelopeSchema = "http://schemas.xmlsoap.org/soap/envelope/"
)

type ServiceOption func(*Service)

func WithClient(c *http.Client) ServiceOption {
	return func(s *Service) {
		s.client = c
	}
}

func WithLocation(u *url.URL) ServiceOption {
	return func(s *Service) {
		s.location = u
	}
}

// State Variables
type AudioInputName string
type Icon string
type LineInConnected bool
type LeftLineInLevel int32
type RightLineInLevel int32
type Playing bool

// Service represents AudioIn service.
type Service struct {
	controlEndpoint  *url.URL
	eventEndpoint    *url.URL
	AudioInputName   *AudioInputName
	Icon             *Icon
	LineInConnected  *LineInConnected
	LeftLineInLevel  *LeftLineInLevel
	RightLineInLevel *RightLineInLevel
	Playing          *Playing
	location         *url.URL
	client           *http.Client
}

// NewService creates a new instance of the AudioIn service.
// You must provide at least a location URL and an HTTP client using the options.
func NewService(opts ...ServiceOption) *Service {
	s := &Service{}

	c, err := url.Parse("/AudioIn/Control")
	if nil != err {
		panic(err)
	}
	e, err := url.Parse("/AudioIn/Event")
	if nil != err {
		panic(err)
	}

	for _, opt := range opts {
		opt(s)
	}

	if s.client == nil {
		panic("no client location")
	}
	if s.location == nil {
		panic("empty location")
	}

	s.controlEndpoint = s.location.ResolveReference(c)
	s.eventEndpoint = s.location.ResolveReference(e)

	return s
}

// ControlEndpoint returns the control endpoint URL of the service.
// This is usually a URL relative to the device's base URL.
func (s *Service) ControlEndpoint() *url.URL {
	return s.controlEndpoint
}

// EventEndpoint returns the event endpoint URL of the service.
// This is usually a URL relative to the device's base URL.
func (s *Service) EventEndpoint() *url.URL {
	return s.eventEndpoint
}

// Location returns the base URL of the device hosting the service.
func (s *Service) Location() *url.URL {
	return s.location
}

// Client returns the HTTP client used to communicate with the service.
func (s *Service) Client() *http.Client {
	return s.client
}

// internal use only
type envelope struct {
	XMLName       xml.Name `xml:"s:Envelope"`
	Xmlns         string   `xml:"xmlns:s,attr"`
	EncodingStyle string   `xml:"s:encodingStyle,attr"`
	Body          body     `xml:"s:Body"`
}

// internal use only
type body struct {
	XMLName                  xml.Name                      `xml:"s:Body"`
	StartTransmissionToGroup *StartTransmissionToGroupArgs `xml:"u:StartTransmissionToGroup,omitempty"`
	StopTransmissionToGroup  *StopTransmissionToGroupArgs  `xml:"u:StopTransmissionToGroup,omitempty"`
	SetAudioInputAttributes  *SetAudioInputAttributesArgs  `xml:"u:SetAudioInputAttributes,omitempty"`
	GetAudioInputAttributes  *GetAudioInputAttributesArgs  `xml:"u:GetAudioInputAttributes,omitempty"`
	SetLineInLevel           *SetLineInLevelArgs           `xml:"u:SetLineInLevel,omitempty"`
	GetLineInLevel           *GetLineInLevelArgs           `xml:"u:GetLineInLevel,omitempty"`
	SelectAudio              *SelectAudioArgs              `xml:"u:SelectAudio,omitempty"`
}

// internal use only
type envelopeResponse struct {
	XMLName       xml.Name     `xml:"Envelope"`
	Xmlns         string       `xml:"xmlns:s,attr"`
	EncodingStyle string       `xml:"encodingStyle,attr"`
	Body          bodyResponse `xml:"Body"`
}

// internal use only
type bodyResponse struct {
	XMLName                  xml.Name                          `xml:"Body"`
	StartTransmissionToGroup *StartTransmissionToGroupResponse `xml:"StartTransmissionToGroupResponse,omitempty"`
	StopTransmissionToGroup  *StopTransmissionToGroupResponse  `xml:"StopTransmissionToGroupResponse,omitempty"`
	SetAudioInputAttributes  *SetAudioInputAttributesResponse  `xml:"SetAudioInputAttributesResponse,omitempty"`
	GetAudioInputAttributes  *GetAudioInputAttributesResponse  `xml:"GetAudioInputAttributesResponse,omitempty"`
	SetLineInLevel           *SetLineInLevelResponse           `xml:"SetLineInLevelResponse,omitempty"`
	GetLineInLevel           *GetLineInLevelResponse           `xml:"GetLineInLevelResponse,omitempty"`
	SelectAudio              *SelectAudioResponse              `xml:"SelectAudioResponse,omitempty"`
}

func (s *Service) exec(actionName string, envelope *envelope) (*envelopeResponse, error) {
	postBody, err := xml.Marshal(envelope)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", s.controlEndpoint.String(), bytes.NewBuffer(postBody))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "text/xml; charset=\"utf-8\"")
	req.Header.Set("SOAPAction", ServiceURN+"#"+actionName)
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	responseBody, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	var envelopeResponse envelopeResponse
	err = xml.Unmarshal(responseBody, &envelopeResponse)
	if err != nil {
		return nil, err
	}
	return &envelopeResponse, nil
}

// StartTransmissionToGroup Argument type.
type StartTransmissionToGroupArgs struct {
	Xmlns         string `xml:"xmlns:u,attr"`
	CoordinatorID string `xml:"CoordinatorID"`
}

// StartTransmissionToGroup Response type.
type StartTransmissionToGroupResponse struct {
	CurrentTransportSettings string `xml:"CurrentTransportSettings"`
}

// StartTransmissionToGroup calls the StartTransmissionToGroup action on the service.
func (s *Service) StartTransmissionToGroup(args *StartTransmissionToGroupArgs) (*StartTransmissionToGroupResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("StartTransmissionToGroup",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{StartTransmissionToGroup: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.StartTransmissionToGroup == nil {
		return nil, errors.New("unexpected response from service calling StartTransmissionToGroup()")
	}

	return r.Body.StartTransmissionToGroup, nil
}

// StopTransmissionToGroup Argument type.
type StopTransmissionToGroupArgs struct {
	Xmlns         string `xml:"xmlns:u,attr"`
	CoordinatorID string `xml:"CoordinatorID"`
}

// StopTransmissionToGroup Response type.
type StopTransmissionToGroupResponse struct {
}

// StopTransmissionToGroup calls the StopTransmissionToGroup action on the service.
func (s *Service) StopTransmissionToGroup(args *StopTransmissionToGroupArgs) (*StopTransmissionToGroupResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("StopTransmissionToGroup",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{StopTransmissionToGroup: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.StopTransmissionToGroup == nil {
		return nil, errors.New("unexpected response from service calling StopTransmissionToGroup()")
	}

	return r.Body.StopTransmissionToGroup, nil
}

// SetAudioInputAttributes Argument type.
type SetAudioInputAttributesArgs struct {
	Xmlns       string `xml:"xmlns:u,attr"`
	DesiredName string `xml:"DesiredName"`
	DesiredIcon string `xml:"DesiredIcon"`
}

// SetAudioInputAttributes Response type.
type SetAudioInputAttributesResponse struct {
}

// SetAudioInputAttributes calls the SetAudioInputAttributes action on the service.
func (s *Service) SetAudioInputAttributes(args *SetAudioInputAttributesArgs) (*SetAudioInputAttributesResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("SetAudioInputAttributes",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{SetAudioInputAttributes: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.SetAudioInputAttributes == nil {
		return nil, errors.New("unexpected response from service calling SetAudioInputAttributes()")
	}

	return r.Body.SetAudioInputAttributes, nil
}

// GetAudioInputAttributes Argument type.
type GetAudioInputAttributesArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}

// GetAudioInputAttributes Response type.
type GetAudioInputAttributesResponse struct {
	CurrentName string `xml:"CurrentName"`
	CurrentIcon string `xml:"CurrentIcon"`
}

// GetAudioInputAttributes calls the GetAudioInputAttributes action on the service.
func (s *Service) GetAudioInputAttributes(args *GetAudioInputAttributesArgs) (*GetAudioInputAttributesResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetAudioInputAttributes",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetAudioInputAttributes: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetAudioInputAttributes == nil {
		return nil, errors.New("unexpected response from service calling GetAudioInputAttributes()")
	}

	return r.Body.GetAudioInputAttributes, nil
}

// SetLineInLevel Argument type.
type SetLineInLevelArgs struct {
	Xmlns                   string `xml:"xmlns:u,attr"`
	DesiredLeftLineInLevel  int32  `xml:"DesiredLeftLineInLevel"`
	DesiredRightLineInLevel int32  `xml:"DesiredRightLineInLevel"`
}

// SetLineInLevel Response type.
type SetLineInLevelResponse struct {
}

// SetLineInLevel calls the SetLineInLevel action on the service.
func (s *Service) SetLineInLevel(args *SetLineInLevelArgs) (*SetLineInLevelResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("SetLineInLevel",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{SetLineInLevel: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.SetLineInLevel == nil {
		return nil, errors.New("unexpected response from service calling SetLineInLevel()")
	}

	return r.Body.SetLineInLevel, nil
}

// GetLineInLevel Argument type.
type GetLineInLevelArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}

// GetLineInLevel Response type.
type GetLineInLevelResponse struct {
	CurrentLeftLineInLevel  int32 `xml:"CurrentLeftLineInLevel"`
	CurrentRightLineInLevel int32 `xml:"CurrentRightLineInLevel"`
}

// GetLineInLevel calls the GetLineInLevel action on the service.
func (s *Service) GetLineInLevel(args *GetLineInLevelArgs) (*GetLineInLevelResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetLineInLevel",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetLineInLevel: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetLineInLevel == nil {
		return nil, errors.New("unexpected response from service calling GetLineInLevel()")
	}

	return r.Body.GetLineInLevel, nil
}

// SelectAudio Argument type.
type SelectAudioArgs struct {
	Xmlns    string `xml:"xmlns:u,attr"`
	ObjectID string `xml:"ObjectID"`
}

// SelectAudio Response type.
type SelectAudioResponse struct {
}

// SelectAudio calls the SelectAudio action on the service.
func (s *Service) SelectAudio(args *SelectAudioArgs) (*SelectAudioResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("SelectAudio",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{SelectAudio: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.SelectAudio == nil {
		return nil, errors.New("unexpected response from service calling SelectAudio()")
	}

	return r.Body.SelectAudio, nil
}

// UpnpEvent represents a UPnP event notification.
type UpnpEvent struct {
	XMLName      xml.Name   `xml:"propertyset"`
	XMLNameSpace string     `xml:"xmlns:e,attr"`
	Properties   []Property `xml:"property"`
}

// Property represents a single property in a UPnP event notification.
type Property struct {
	XMLName          xml.Name          `xml:"property"`
	AudioInputName   *AudioInputName   `xml:"AudioInputName"`
	Icon             *Icon             `xml:"Icon"`
	LineInConnected  *LineInConnected  `xml:"LineInConnected"`
	LeftLineInLevel  *LeftLineInLevel  `xml:"LeftLineInLevel"`
	RightLineInLevel *RightLineInLevel `xml:"RightLineInLevel"`
	Playing          *Playing          `xml:"Playing"`
}

// ParseEvent parses a UPnP event notification and updates the service's state variables accordingly.
// It returns a slice of updated state variable values.
func (zp *Service) ParseEvent(body []byte) []interface{} {
	var evt UpnpEvent
	var events []interface{}

	if err := xml.Unmarshal(body, &evt); err != nil {
		return events
	}
	for _, prop := range evt.Properties {
		_ = prop
		switch {
		case prop.AudioInputName != nil:
			zp.AudioInputName = prop.AudioInputName
			events = append(events, *prop.AudioInputName)
		case prop.Icon != nil:
			zp.Icon = prop.Icon
			events = append(events, *prop.Icon)
		case prop.LineInConnected != nil:
			zp.LineInConnected = prop.LineInConnected
			events = append(events, *prop.LineInConnected)
		case prop.LeftLineInLevel != nil:
			zp.LeftLineInLevel = prop.LeftLineInLevel
			events = append(events, *prop.LeftLineInLevel)
		case prop.RightLineInLevel != nil:
			zp.RightLineInLevel = prop.RightLineInLevel
			events = append(events, *prop.RightLineInLevel)
		case prop.Playing != nil:
			zp.Playing = prop.Playing
			events = append(events, *prop.Playing)
		}
	}
	return events
}
